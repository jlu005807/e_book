面向对象_task10

# 类的大小

与非静态数据**成员的个数、类型有关**

与**成员函数的个数无关**

与静态数据成员的多少 、类型无关

与访问控制无关

一定非0

与是否含有**虚函数有关**

与编译时字节对齐方式设置有关

# 数据成员

普通类型（指针、数组、引用等)

 enum类型、 const 类型、static 类型

 struct 和class 不能递归定义，但可用指针



# 实例化

对象:类的实例化结果。

一个对象总是有类型的

一个类型可实例化0个或多个对象

##### 对象的访问

1. 调用函数与发送消息

2. 直接向对象发送消息

3. 向指针指向的对象发送消息

4. 向引用对象发送消息

面向对象中更强调发送消息，接收对象及其相应行为是**不确定的**，也可能**不是同步**的。

# 基本数据类型大小:

在C++中，不同的数据类型具有不同的大小，这些大小通常依赖于具体的编译器和平台。以下是标准数据类型在常见平台（如32位和64位系统）上的典型大小：

1. **整型（Integer Types）**

    - `char`: 通常为1字节（8位）。
    - `signed char`: 通常为1字节（8位）。
    - `unsigned char`: 通常为1字节（8位）。
    - `short`: 通常为**2**字节（16位）。
    - `unsigned short`: 通常为2字节（16位）。
    - `int`: 通常为4字节（32位）。
    - `unsigned int`: 通常为4字节（32位）。
    - `long`: 在32位系统上通常为4字节（32位），在64位系统上有时为8字节（64位）。
    - `unsigned long`: 在32位系统上通常为4字节（32位），在64位系统上有时为8字节（64位）。
    - `long long`: 通常为**8**字节（64位）。
    - `unsigned long long`: 通常为8字节（64位）。

2. **浮点型（Floating-Point Types）**

    - `float`: 通常为**4**字节（32位）。
    - `double`: 通常为**8**字节（64位）。
    - `long double`: 通常为**8**字节（64位），在某些系统上为12字节（96位）或16字节（128位）。

3. **布尔型（Boolean Type）**

    - `bool`: 通常为1字节（8位）。

4. **指针类型（Pointer Types）**
- 指针的大小通常取决于平台。在32位系统上，指针通常为4字节（32位）；在64位系统上，指针通常为8字节（64位）。

注: `const`并不会改变变量的大小，它仅仅是对变量的性质进行修饰，使其变成只读。



# 虚机制

**静态编连**: 编译期间就决定了程序运行时将具体调用哪个**函数体**。即使没有主程序，也能知道程序中各个**函数体**之间的调用关系。

**动态编联**(晚绑定，动态绑定): 在运行期间，决定具体调用哪个**函数体**。

动态编联的实现 : **虚机制**（使用虚拟函数和虚拟函数表）

# 虚函数声明与定义



### 虚函数的格式(必须是非静态成员函数)

声明：**virtual** 返回类型 函数名(参数列表)[const];

定义：同一般成员函数

### 虚函数说明：

必须是成员函数

**静态成员函数**和**构造函数**、**拷贝构造函数**不能是虚的

**析构函数可以是虚的**，若有派生类，则应该是虚的

若类中有其它**虚函数**，那么析构函数也应该是虚的

赋值函数通常**不定义为虚的**

虚函数const修饰**任意**

访问控制可以**任意** (public、protected、private）

### **派生类中的虚函数**

通常采用**public**继承方式

继承自基类的虚函数（**除**虚的析构函数）

若基类的析构函数是虚的，那么派生类中的析构函数**也是虚的**

派生类中新的虚函数

##### 派生类override基类中虚函数(或复写、重写、覆盖）

1. 函数**名字**同基类中虚函数的名字

2. virtual关键字**可省略**

3. 返回类型必须与基类中虚函数的**返回类型**相同或相容

4. 可能会**隐藏**基类中重载的虚函数(overwrite,hide)

5. 可选override说明符

### **虚函数表(虚拟表、虚表、VTable)**

##### 虚函数表：

一个指针数组，各元素存放对应虚函数的入口地址

##### 说明：

1. 要求对应的类中至少有一个虚函数

2. 一个类至多有一个虚拟表，同一个类的不同对象共享该虚拟表

3. 首次创建该类实例对象时，在内存中同时创建该类的虚拟表

4. 按照函数顺序的序号依次存放入口地址

**虚函数的作用机制**--函数调用的编译

编译过程 (以p->Func( ) 为例 )

确定p的静态类型，如A *

在A类中，寻找名字为Func，且参数可以匹配的函数

若找不到，编译错误。

若找到，该函数为virtual函数吗？

若不是，编译成p->A::Func( );

**若是虚函数，采用动态编联，从而编译成** 

```
(* p->vptr )[index]((void *)p,…);
```

即在运行时，根据vptr中的函数入口地址，选择执行函数。

> [!NOTE]
>
> *若希望pObj->Func( ); 或 obj.Func( ); 合法，必须有：*
>
> *pObj / obj的**静态类型**中必须有匹配的函数Func；*
>
> **即使匹配的Func，永远不被调用，也要有**

### 虚函数的访问